<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>LiveKit Voice Assistant - Realtime API</title>
    <script src="https://unpkg.com/@livekit/components-core@0.11.5/dist/livekit-components-core.umd.js"></script>
    <script src="https://unpkg.com/livekit-client@latest/dist/livekit-client.umd.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 100%;
            padding: 40px;
            max-height: 90vh;
            overflow-y: auto;
        }
        h1 { text-align: center; color: #333; margin-bottom: 10px; font-size: 28px; }
        .subtitle { text-align: center; color: #666; margin-bottom: 20px; font-size: 14px; }
        .form-row { display: flex; gap: 12px; }
        .form-row .form-group { flex: 1; }
        .form-group { margin-bottom: 12px; }
        label { display: block; margin-bottom: 8px; color: #333; font-weight: 600; font-size: 14px; }
        input, select { width: 100%; padding: 10px 12px; border: 2px solid #e0e0e0; border-radius: 10px; font-size: 14px; transition: all 0.2s; }
        input:focus, select:focus { outline: none; border-color: #667eea; box-shadow: 0 0 0 3px rgba(102,126,234,0.08); }
        .checkbox-group { display: flex; align-items: center; gap: 10px; margin-bottom: 12px; }
        .checkbox-group input[type="checkbox"] { width: auto; margin: 0; }
        .checkbox-group label { margin: 0; font-size: 13px; font-weight: 500; }
        button { padding: 12px; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer; transition: all 0.2s; }
        #startBtn { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; width: 100%; }
        #startBtn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3); }
        #startBtn:disabled { opacity: 0.6; cursor: not-allowed; }
        #endBtn { background: #f44336; color: white; display: none; width: 100%; margin-top: 8px; }
        #endBtn:hover { background: #d32f2f; }
        .status { text-align: center; padding: 10px; border-radius: 10px; margin-top: 12px; font-size: 14px; font-weight: 600; display: none; }
        .status.connecting { background: #fff3e0; color: #f57c00; display: block; }
        .status.connected { background: #e8f5e9; color: #2e7d32; display: block; }
        .status.error { background: #ffebee; color: #c62828; display: block; }
        .audio-visualizer { display: none; margin: 12px auto; text-align: center; }
        .audio-visualizer.active { display: block; }
        .wave { display: inline-block; width: 4px; height: 20px; background: #667eea; margin: 0 2px; border-radius: 2px; animation: wave 1s ease-in-out infinite; }
        .wave:nth-child(2) { animation-delay: 0.1s; }
        .wave:nth-child(3) { animation-delay: 0.2s; }
        .wave:nth-child(4) { animation-delay: 0.3s; }
        .wave:nth-child(5) { animation-delay: 0.4s; }
        @keyframes wave { 0%, 100% { height: 20px; } 50% { height: 40px; } }

        .chat-box {
            margin-top: 18px;
            border: 1px solid #e6e6e6;
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 320px;
        }
        .chat-box.active { display: flex !important; }
        .chat-header {
            background: linear-gradient(90deg,#f7f9fc,#eef2ff);
            padding: 10px 12px;
            font-weight: 700;
            font-size: 14px;
            color: #333;
            border-bottom: 1px solid #eee;
        }

        /* ===== LINK MESSAGE STYLING ===== */
        .link-message {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%) !important;
            border-left: 4px solid #2196f3;
            padding: 14px !important;
            max-width: 85% !important;
        }
        .link-icon {
            font-size: 24px;
            margin-bottom: 6px;
        }
        .chat-link {
            color: #1565c0;
            text-decoration: none;
            display: block;
            transition: all 0.2s;
        }
        .chat-link:hover {
            color: #0d47a1;
            text-decoration: underline;
        }
        .chat-link strong {
            font-size: 15px;
            display: block;
            margin-bottom: 4px;
        }
        .link-url {
            font-size: 11px;
            color: #666;
            margin-top: 4px;
            word-break: break-all;
            opacity: 0.8;
        }

        .chat-messages {
            padding: 12px;
            flex: 1;
            overflow-y: auto;
            background: #fafafa;
            font-size: 14px;
        }
        .chat-row { margin-bottom: 12px; display: flex; align-items: flex-start; }
        .chat-row.user { justify-content: flex-end; }
        .chat-row.agent { justify-content: flex-start; }
        .chat-text { 
            padding: 10px 14px; 
            border-radius: 18px; 
            max-width: 75%; 
            word-break: break-word; 
            font-size: 14px;
            line-height: 1.4;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .chat-text.agent { background: #f0f0f0; color: #333; border-bottom-left-radius: 6px; }
        .chat-text.user { background: #667eea; color: white; border-bottom-right-radius: 6px; }
        .chat-meta { font-size: 10px; color: #999; margin-top: 4px; text-align: center; }
        .chat-input-row { display:flex; gap:8px; padding: 10px; border-top:1px solid #eee; background:white; }
        .chat-input-row input[type="text"] { flex:1; padding:8px 10px; border-radius:8px; border:1px solid #ddd; font-size:14px; }
        .chat-input-row button { padding:8px 12px; border-radius:8px; background:#667eea; color:white; border:none; cursor:pointer; }

        /* ===== DOCUMENT UPLOAD STYLING ===== */
        .upload-section {
            margin-top: 12px;
            padding: 16px;
            border: 2px dashed #ddd;
            border-radius: 12px;
            text-align: center;
            transition: all 0.3s;
            background: #fafafa;
        }
        .upload-section.active {
            display: block;
        }
        .upload-section.dragover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.08);
        }
        .upload-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            display: inline-block;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.2s;
        }
        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        .upload-info {
            font-size: 12px;
            color: #888;
            margin-top: 8px;
        }
        .upload-status {
            margin-top: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 13px;
            display: none;
        }
        .upload-status.uploading {
            display: block;
            background: #fff3e0;
            color: #f57c00;
        }
        .upload-status.success {
            display: block;
            background: #e8f5e9;
            color: #2e7d32;
        }
        .upload-status.error {
            display: block;
            background: #ffebee;
            color: #c62828;
        }
        #fileInput {
            display: none;
        }

        /* Document message in chat */
        .doc-message {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%) !important;
            border-left: 4px solid #4caf50;
            padding: 14px !important;
            max-width: 85% !important;
        }
        .doc-icon {
            font-size: 24px;
            margin-bottom: 6px;
        }
        .doc-name {
            font-weight: 600;
            font-size: 14px;
            color: #2e7d32;
        }
        .doc-info {
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }

        .latency-monitor { display: none; margin-top: 12px; padding: 12px; background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); border-radius: 12px; }
        .latency-monitor.active { display:block; }
        .latency-header { font-size: 16px; font-weight: 700; color: #333; margin-bottom: 15px; }
        .latency-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
        .latency-metric { background: white; padding: 12px; border-radius: 8px; }
        .latency-label { font-size: 11px; font-weight: 600; color: #666; text-transform: uppercase; }
        .latency-value { font-size: 20px; font-weight: 700; color: #333; }
        .latency-value.good { color: #2e7d32; }
        .latency-value.medium { color: #f57c00; }
        .latency-value.bad { color: #c62828; }
        .latency-chart { margin-top: 15px; background: white; padding: 15px; border-radius: 8px; height: 80px; position: relative; overflow: hidden; }
        .latency-bar { position: absolute; bottom: 0; width: 3px; background: #667eea; transition: height 0.3s ease; border-radius: 2px 2px 0 0; }
        .latency-stats { margin-top: 12px; font-size: 11px; color: #666; text-align: center; }

        .transcript-box { display:none; margin-top:12px; padding:12px; background:#f5f5f5; border-radius:10px; max-height:180px; overflow-y:auto; }
        .transcript-box.active { display:block; }
        .transcript-item { margin-bottom:8px; padding:8px; border-radius:8px; font-size:13px; line-height:1.4; }
        .transcript-item.user { background: #e3f2fd; color:#1565c0; }
        .transcript-item.agent { background: #f3e5f5; color:#6a1b9a; }
        .transcript-label { font-weight: 600; margin-bottom: 4px; }

        .noise-indicator { display:none; margin-top:10px; padding:8px 12px; background:#e8f5e9; border-radius:8px; font-size:12px; color:#2e7d32; text-align:center; }
        .noise-indicator.active { display:block; }

        .container::-webkit-scrollbar, .transcript-box::-webkit-scrollbar, .chat-messages::-webkit-scrollbar { width: 6px; }
        .container::-webkit-scrollbar-track, .transcript-box::-webkit-scrollbar-track, .chat-messages::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        .container::-webkit-scrollbar-thumb, .transcript-box::-webkit-scrollbar-thumb, .chat-messages::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }

        @media (max-width: 640px) {
            .container { padding: 16px; }
            .chat-box { height: 260px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéôÔ∏è Voice Assistant</h1>
        <p class="subtitle">LiveKit</p>

        <div class="form-row" style="margin-bottom:12px;">
            <div class="form-group" style="flex:1;">
                <label for="agentId">Agent ID</label>
                <input type="text" id="agentId" placeholder="Enter agent ID (optional)">
            </div>
            <div class="form-group" style="width:150px;">
                <label for="language">Language</label>
                <select id="language">
                    <option value="en">English</option>
                    <option value="hi">Hindi</option>
                    <option value="es">Spanish</option>
                    <option value="fr">French</option>
                    <option value="de">German</option>
                    <option value="pt">Portuguese</option>
                    <option value="zh">Chinese</option>
                    <option value="ja">Japanese</option>
                    <option value="ko">Korean</option>
                    <option value="ar">Arabic</option>
                    <option value="ru">Russian</option>
                    <option value="it">Italian</option>
                    <option value="nl">Dutch</option>
                    <option value="pl">Polish</option>
                    <option value="tr">Turkish</option>
                </select>
            </div>
        </div>

        <div class="checkbox-group">
            <input type="checkbox" id="noiseSuppression" checked>
            <label for="noiseSuppression">üéß Enable Noise Cancellation</label>
        </div>
        <div class="checkbox-group">
            <input type="checkbox" id="echoCancellation" checked>
            <label for="echoCancellation">üîä Enable Echo Cancellation</label>
        </div>
        <div class="checkbox-group">
            <input type="checkbox" id="autoGainControl" checked>
            <label for="autoGainControl">üìä Enable Auto Gain Control</label>
        </div>

        <div style="display:flex; gap:8px; margin-bottom:8px;">
            <button id="startBtn">Start Call</button>
            <button id="endBtn">End Call</button>
        </div>

        <div class="noise-indicator" id="noiseIndicator">üéôÔ∏è Audio processing active</div>
        <div class="audio-visualizer"><div class="wave"></div><div class="wave"></div><div class="wave"></div><div class="wave"></div><div class="wave"></div></div>
        <div id="status" class="status"></div>

        <div class="chat-box" id="chatBox" aria-live="polite">
            <div class="chat-header">Realtime Chat</div>
            <div id="chatMessages" class="chat-messages"></div>
            <div class="chat-input-row">
                <input id="chatInput" type="text" placeholder="Type a message..." autocomplete="off" />
                <button id="sendChatBtn">Send</button>
            </div>
        </div>

        <!-- Document Upload Section -->
        <div class="upload-section" id="uploadSection">
            <input type="file" id="fileInput" accept=".pdf,.docx,.doc,.txt,.md">
            <label for="fileInput" class="upload-btn">üìÑ Upload Document</label>
            <div class="upload-info">Supported: PDF, DOCX, TXT (Max 7MB)</div>
            <div id="uploadStatus" class="upload-status"></div>
        </div>

        <div id="latencyMonitor" class="latency-monitor">
            <div class="latency-header">Latency</div>
            <div class="latency-grid">
                <div class="latency-metric"><div class="latency-label">Current</div><div id="currentLatency" class="latency-value">-- ms</div></div>
                <div class="latency-metric"><div class="latency-label">Average</div><div id="avgLatency" class="latency-value">-- ms</div></div>
                <div class="latency-metric"><div class="latency-label">Best</div><div id="minLatency" class="latency-value">-- ms</div></div>
                <div class="latency-metric"><div class="latency-label">Worst</div><div id="maxLatency" class="latency-value">-- ms</div></div>
            </div>
            <div class="latency-chart" id="latencyChart"></div>
            <div class="latency-stats"><span id="totalExchanges">0 exchanges</span> ‚Ä¢ Target: &lt;500ms excellent</div>
        </div>

        <div id="transcriptBox" class="transcript-box">
            <h3 style="margin-bottom: 8px; color: #333; font-size: 14px;">üìù Conversation Log</h3>
            <div id="transcriptContent"></div>
        </div>
    </div>

    <script>
        // =====================================================================
        // HINDI TRANSLITERATOR - Clean, readable output
        // =====================================================================
        
        const HindiTransliterator = (function() {
            'use strict';
            
            const VOWELS = {
                '‡§Ö': 'a',   '‡§Ü': 'aa',  '‡§á': 'i',   '‡§à': 'ee',  '‡§â': 'u',   '‡§ä': 'oo',
                '‡§ã': 'ri',  '‡•†': 'ri',  '‡§å': 'li',  '‡•°': 'li',
                '‡§è': 'e',   '‡§ê': 'ai',  '‡§ì': 'o',   '‡§î': 'au',
                '‡§ë': 'o',   '‡§ç': 'e'
            };
            
            const CONSONANTS = {
                '‡§ï': 'k',   '‡§ñ': 'kh',  '‡§ó': 'g',   '‡§ò': 'gh',  '‡§ô': 'n',
                '‡§ö': 'ch',  '‡§õ': 'chh', '‡§ú': 'j',   '‡§ù': 'jh',  '‡§û': 'n',
                '‡§ü': 't',   '‡§†': 'th',  '‡§°': 'd',   '‡§¢': 'dh',  '‡§£': 'n',
                '‡§§': 't',   '‡§•': 'th',  '‡§¶': 'd',   '‡§ß': 'dh',  '‡§®': 'n',
                '‡§™': 'p',   '‡§´': 'ph',  '‡§¨': 'b',   '‡§≠': 'bh',  '‡§Æ': 'm',
                '‡§Ø': 'y',   '‡§∞': 'r',   '‡§≤': 'l',   '‡§µ': 'v',
                '‡§∂': 'sh',  '‡§∑': 'sh',  '‡§∏': 's',   '‡§π': 'h',
                '‡§ï‡§º': 'q',   '‡§ñ‡§º': 'kh',  '‡§ó‡§º': 'gh',  '‡§ú‡§º': 'z',
                '‡§°‡§º': 'r',   '‡§¢‡§º': 'rh',  '‡§´‡§º': 'f',   '‡§Ø‡§º': 'y',
                '‡§≥': 'l',   '‡§¥': 'l'
            };
            
            const MATRAS = {
                '‡§æ': 'aa',  '‡§ø': 'i',   '‡•Ä': 'ee',  '‡•Å': 'u',   '‡•Ç': 'oo',
                '‡•É': 'ri',  '‡•Ñ': 'ri',  '‡•¢': 'li',  '‡•£': 'li',
                '‡•á': 'e',   '‡•à': 'ai',  '‡•ã': 'o',   '‡•å': 'au',
                '‡•â': 'o',   '‡•Ö': 'e'
            };
            
            const SIGNS = {
                '‡§Ç': 'n',   '‡§É': 'h',   '‡§Å': 'n',   '‡§Ω': '',    '‡•∞': '.'
            };
            
            const NUMERALS = {
                '‡•¶': '0', '‡•ß': '1', '‡•®': '2', '‡•©': '3', '‡•™': '4',
                '‡•´': '5', '‡•¨': '6', '‡•≠': '7', '‡•Æ': '8', '‡•Ø': '9'
            };
            
            const VIRAMA = '‡•ç';
            
            function isDevanagari(char) {
                const code = char.charCodeAt(0);
                return code >= 0x0900 && code <= 0x097F;
            }
            
            function containsDevanagari(text) {
                return /[\u0900-\u097F]/.test(text);
            }
            
            function getAnusvaraSound(nextConsonant) {
                if (!nextConsonant) return 'n';
                if ('‡§™‡§´‡§¨‡§≠‡§Æ'.includes(nextConsonant)) return 'm';
                if ('‡§ï‡§ñ‡§ó‡§ò‡§ô'.includes(nextConsonant)) return 'n';
                return 'n';
            }
            
            function transliterate(text) {
                if (!text || typeof text !== 'string') return text;
                if (!containsDevanagari(text)) return text;
                
                let result = '';
                let i = 0;
                const len = text.length;
                
                while (i < len) {
                    const char = text[i];
                    const next1 = text[i + 1];
                    const next2 = text[i + 2];
                    
                    if (!isDevanagari(char)) {
                        result += char;
                        i++;
                        continue;
                    }
                    
                    if (VOWELS[char]) {
                        result += VOWELS[char];
                        i++;
                        continue;
                    }
                    
                    if (CONSONANTS[char]) {
                        const consonant = CONSONANTS[char];
                        
                        if (next1 === VIRAMA) {
                            result += consonant;
                            i += 2;
                            continue;
                        }
                        
                        if (next1 && MATRAS[next1]) {
                            let syllable = consonant + MATRAS[next1];
                            i += 2;
                            
                            if (text[i] === '‡§Ç') {
                                const nextCons = text[i + 1];
                                syllable += getAnusvaraSound(nextCons);
                                i++;
                            } else if (text[i] === '‡§É') {
                                syllable += 'h';
                                i++;
                            } else if (text[i] === '‡§Å') {
                                syllable += 'n';
                                i++;
                            }
                            
                            result += syllable;
                            continue;
                        }
                        
                        if (next1 === '‡§Ç') {
                            const nextCons = text[i + 2];
                            result += consonant + 'a' + getAnusvaraSound(nextCons);
                            i += 2;
                            continue;
                        }
                        
                        if (next1 && SIGNS[next1]) {
                            result += consonant + 'a' + SIGNS[next1];
                            i += 2;
                            continue;
                        }
                        
                        result += consonant + 'a';
                        i++;
                        continue;
                    }
                    
                    if (MATRAS[char]) {
                        result += MATRAS[char];
                        i++;
                        continue;
                    }
                    
                    if (SIGNS[char]) {
                        result += SIGNS[char];
                        i++;
                        continue;
                    }
                    
                    if (NUMERALS[char]) {
                        result += NUMERALS[char];
                        i++;
                        continue;
                    }
                    
                    if (char === VIRAMA) {
                        i++;
                        continue;
                    }
                    
                    result += char;
                    i++;
                }
                
                result = applySchwaRule(result);
                
                return result;
            }
            
            function applySchwaRule(text) {
                return text.split(/(\s+)/).map(word => {
                    if (!word.match(/[a-z]/i)) return word;
                    if (word.length <= 2) return word;
                    
                    if (word.endsWith('a') && word.length > 3) {
                        word = word.slice(0, -1);
                    }
                    
                    word = word
                        .replace(/aa/g, 'a')
                        .replace(/ee/g, 'i')
                        .replace(/oo/g, 'u')
                        .replace(/ai/g, 'ai')
                        .replace(/au/g, 'au');
                    
                    return word;
                }).join('');
            }
            
            return {
                transliterate: transliterate,
                containsDevanagari: containsDevanagari,
                
                test: function() {
                    const tests = [
                        ['‡§®‡•à‡§®‡•Ä‡§§‡§æ‡§≤', 'nainital'],
                        ['‡§™‡§Ç‡§ó‡•ã‡§ü', 'pangot'],
                        ['‡§®‡§Æ‡§∏‡•ç‡§§‡•á', 'namaste'],
                        ['‡§¶‡§ø‡§≤‡•ç‡§≤‡•Ä', 'dilli'],
                        ['‡§Æ‡•Å‡§Ç‡§¨‡§à', 'mumbai'],
                        ['‡§π‡§ø‡§Æ‡§æ‡§≤‡§Ø', 'himalay'],
                        ['‡§ú‡§Ç‡§ó‡§≤', 'jangal'],
                        ['‡§ö‡§ø‡§°‡§º‡§ø‡§Ø‡§æ', 'chidiya'],
                        ['‡§ñ‡§æ‡§®‡§æ', 'khana'],
                        ['‡§≠‡§æ‡§∞‡§§', 'bharat']
                    ];
                    
                    console.log('=== Hindi Transliterator Test ===');
                    let passed = 0, failed = 0;
                    
                    tests.forEach(([input, expected]) => {
                        const result = transliterate(input);
                        const match = result.toLowerCase() === expected.toLowerCase();
                        if (match) {
                            console.log(`‚úÖ ${input} ‚Üí ${result}`);
                            passed++;
                        } else {
                            console.log(`‚ùå ${input} ‚Üí ${result} (expected: ${expected})`);
                            failed++;
                        }
                    });
                    
                    console.log(`\n=== Results: ${passed} passed, ${failed} failed ===`);
                    return { passed, failed };
                }
            };
        })();

        function cleanTranscript(text) {
            if (!text || typeof text !== 'string') return text;
            if (!HindiTransliterator.containsDevanagari(text)) return text;
            
            const result = HindiTransliterator.transliterate(text);
            console.log('üî§ Transliterated:', { original: text.substring(0, 50), result: result.substring(0, 50) });
            return result;
        }

        // =====================================================================
        // STATE & ELEMENTS
        // =====================================================================
        let room = null;
        let isConnected = false;
        let localAudioTrack = null;
        let remoteAudioTrack = null;

        const startBtn = document.getElementById('startBtn');
        const endBtn = document.getElementById('endBtn');
        const statusDiv = document.getElementById('status');
        const agentIdInput = document.getElementById('agentId');
        const languageSelect = document.getElementById('language');
        const visualizer = document.querySelector('.audio-visualizer');
        const transcriptBox = document.getElementById('transcriptBox');
        const transcriptContent = document.getElementById('transcriptContent');
        const noiseIndicator = document.getElementById('noiseIndicator');
        const noiseSuppressionCheckbox = document.getElementById('noiseSuppression');
        const echoCancellationCheckbox = document.getElementById('echoCancellation');
        const autoGainControlCheckbox = document.getElementById('autoGainControl');
        const chatBox = document.getElementById('chatBox');
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendChatBtn = document.getElementById('sendChatBtn');

        let latencyMetrics = {
            userSpeechStartTime: null,
            userSpeechEndTime: null,
            agentResponseStartTime: null,
            measurements: [],
            maxSamples: 30,
            isSpeaking: false,
            isAgentSpeaking: false
        };

        const latencyMonitor = document.getElementById('latencyMonitor');
        const currentLatencyEl = document.getElementById('currentLatency');
        const avgLatencyEl = document.getElementById('avgLatency');
        const minLatencyEl = document.getElementById('minLatency');
        const maxLatencyEl = document.getElementById('maxLatency');
        const totalExchangesEl = document.getElementById('totalExchanges');
        const latencyChart = document.getElementById('latencyChart');

        // =====================================================================
        // UTILITY FUNCTIONS
        // =====================================================================
        function setStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
        }

        function getLatencyClass(ms) {
            if (ms < 500) return 'good';
            if (ms < 800) return 'medium';
            return 'bad';
        }

        function updateLatencyDisplay() {
            if (latencyMetrics.measurements.length === 0) return;
            const current = latencyMetrics.measurements[latencyMetrics.measurements.length - 1];
            const avg = latencyMetrics.measurements.reduce((a, b) => a + b, 0) / latencyMetrics.measurements.length;
            const min = Math.min(...latencyMetrics.measurements);
            const max = Math.max(...latencyMetrics.measurements);

            currentLatencyEl.textContent = `${Math.round(current)} ms`;
            currentLatencyEl.className = `latency-value ${getLatencyClass(current)}`;
            avgLatencyEl.textContent = `${Math.round(avg)} ms`;
            avgLatencyEl.className = `latency-value ${getLatencyClass(avg)}`;
            minLatencyEl.textContent = `${Math.round(min)} ms`;
            minLatencyEl.className = `latency-value ${getLatencyClass(min)}`;
            maxLatencyEl.textContent = `${Math.round(max)} ms`;
            maxLatencyEl.className = `latency-value ${getLatencyClass(max)}`;
            totalExchangesEl.textContent = `${latencyMetrics.measurements.length} exchanges`;
            updateLatencyChart();
        }

        function updateLatencyChart() {
            latencyChart.innerHTML = '';
            const measurements = latencyMetrics.measurements.slice(-30);
            if (measurements.length === 0) return;
            const maxValue = Math.max(...measurements, 1000);
            const width = latencyChart.clientWidth || 300;
            const barWidth = Math.max(2, width / measurements.length - 2);
            measurements.forEach((value, index) => {
                const bar = document.createElement('div');
                bar.className = 'latency-bar';
                bar.style.left = `${(index / measurements.length) * 100}%`;
                bar.style.height = `${(value / maxValue) * 80}px`;
                bar.style.width = `${barWidth}px`;
                const colorClass = getLatencyClass(value);
                bar.style.background = colorClass === 'good' ? '#4caf50' : colorClass === 'medium' ? '#ff9800' : '#f44336';
                latencyChart.appendChild(bar);
            });
        }

        function addLog(text, source) {
            const item = document.createElement('div');
            item.className = `transcript-item ${source}`;
            const time = new Date().toLocaleTimeString();
            item.innerHTML = `<div class="transcript-label">${source === 'user' ? 'üë§ You' : 'ü§ñ Agent'} - ${time}</div><div>${text}</div>`;
            transcriptContent.appendChild(item);
            transcriptBox.scrollTop = transcriptBox.scrollHeight;
            transcriptBox.classList.add('active');
        }

        // =====================================================================
        // CHAT FUNCTIONS
        // =====================================================================
        function appendChatMessage(sender, message, meta = {}) {
            if (meta.role === 'system') return;
            
            const row = document.createElement('div');
            row.className = 'chat-row';
            const text = document.createElement('div');
            text.className = 'chat-text';
            
            const isUser = meta.role === 'user' || sender === 'You' || sender.includes('You');
            row.classList.add(isUser ? 'user' : 'agent');
            text.classList.add(isUser ? 'user' : 'agent');

            const cleanedMessage = cleanTranscript(message);
            text.innerHTML = cleanedMessage.replace(/\n/g, '<br/>');
            row.appendChild(text);

            if (meta.time) {
                const metaDiv = document.createElement('div');
                metaDiv.className = 'chat-meta';
                metaDiv.textContent = meta.time;
                row.appendChild(metaDiv);
            }

            chatMessages.appendChild(row);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            console.log('Chat:', isUser ? 'User' : 'AI', '|', message.substring(0, 40), '‚Üí', cleanedMessage.substring(0, 40));
        }

        function appendLinkMessage(title, url, timestamp) {
            const row = document.createElement('div');
            row.className = 'chat-row agent';
            
            const linkBox = document.createElement('div');
            linkBox.className = 'chat-text agent link-message';
            
            linkBox.innerHTML = `
                <div class="link-icon">üîó</div>
                <a href="${url}" target="_blank" rel="noopener noreferrer" class="chat-link">
                    <strong>${title}</strong>
                    <div class="link-url">${url}</div>
                </a>
            `;
            
            row.appendChild(linkBox);
            
            if (timestamp) {
                const metaDiv = document.createElement('div');
                metaDiv.className = 'chat-meta';
                metaDiv.textContent = new Date(timestamp).toLocaleTimeString();
                row.appendChild(metaDiv);
            }
            
            chatMessages.appendChild(row);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            console.log('üìé Link displayed:', title, '‚Üí', url);
        }

        function sendChat() {
            if (!isConnected || !room) {
                setStatus('Join a room to send chat', 'error');
                return;
            }
            const text = chatInput.value.trim();
            if (!text) return;
            
            try {
                if (typeof room.localParticipant.sendText === 'function') {
                    room.localParticipant.sendText(text, { topic: 'lk.chat' })
                        .catch(() => fallbackSendChat(text));
                } else {
                    fallbackSendChat(text);
                }
                appendChatMessage('You', text, { time: new Date().toLocaleTimeString() });
                chatInput.value = '';
                chatInput.focus();
            } catch (e) {
                console.error('Failed to send chat:', e);
            }
        }

        function fallbackSendChat(text) {
            try {
                const encoder = new TextEncoder();
                room.localParticipant.publishData(
                    encoder.encode(JSON.stringify({ type: 'chat', text, timestamp: Date.now() })),
                    { reliable: true, destinationIdentities: [], topic: 'lk.chat' }
                );
            } catch (e) { console.error('fallback send failed', e); }
        }

        sendChatBtn.addEventListener('click', sendChat);
        chatInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') sendChat(); });

        // =====================================================================
        // DOCUMENT UPLOAD FUNCTIONS
        // =====================================================================
        const fileInput = document.getElementById('fileInput');
        const uploadSection = document.getElementById('uploadSection');
        const uploadStatus = document.getElementById('uploadStatus');

        const SUPPORTED_TYPES = ['.pdf', '.docx', '.doc', '.txt', '.md'];
        const MAX_FILE_SIZE = 7 * 1024 * 1024; // 7MB

        function showUploadStatus(message, type) {
            uploadStatus.textContent = message;
            uploadStatus.className = `upload-status ${type}`;
        }

        function appendDocMessage(filename, status, info = '') {
            const row = document.createElement('div');
            row.className = 'chat-row user';
            
            const docBox = document.createElement('div');
            docBox.className = 'chat-text user doc-message';
            
            const icon = status === 'uploading' ? '‚è≥' : status === 'success' ? 'üìÑ' : '‚ùå';
            const statusText = status === 'uploading' ? 'Uploading...' : status === 'success' ? 'Uploaded' : 'Failed';
            
            docBox.innerHTML = `
                <div class="doc-icon">${icon}</div>
                <div class="doc-name">${filename}</div>
                <div class="doc-info">${statusText}${info ? ' ‚Ä¢ ' + info : ''}</div>
            `;
            
            row.appendChild(docBox);
            chatMessages.appendChild(row);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            
            return row;
        }

        async function uploadDocument(file) {
            // Validate file type
            const ext = '.' + file.name.toLowerCase().split('.').pop();
            if (!SUPPORTED_TYPES.includes(ext)) {
                showUploadStatus(`‚ùå Unsupported file type: ${ext}`, 'error');
                return;
            }
            
            // Validate file size
            if (file.size > MAX_FILE_SIZE) {
                showUploadStatus(`‚ùå File too large. Max size: 7MB`, 'error');
                return;
            }
            
            // Show uploading status
            showUploadStatus(`üì§ Uploading ${file.name}...`, 'uploading');
            const docRow = appendDocMessage(file.name, 'uploading', formatFileSize(file.size));
            
            try {
                // Read file as base64
                const base64Data = await readFileAsBase64(file);
                
                // Send via LiveKit data channel
                const message = JSON.stringify({
                    type: 'file_upload',
                    filename: file.name,
                    data: base64Data,
                    size: file.size,
                    timestamp: Date.now()
                });
                
                const encoder = new TextEncoder();
                await room.localParticipant.publishData(
                    encoder.encode(message),
                    { reliable: true }
                );
                
                // Update status
                showUploadStatus(`‚úÖ ${file.name} uploaded!`, 'success');
                docRow.querySelector('.doc-icon').textContent = 'üìÑ';
                docRow.querySelector('.doc-info').textContent = `Uploaded ‚Ä¢ ${formatFileSize(file.size)}`;
                
                // Add to log
                addLog(`Uploaded document: ${file.name}`, 'user');
                
                console.log('üìÑ Document uploaded:', file.name, formatFileSize(file.size));
                
                // Clear status after 3 seconds
                setTimeout(() => {
                    uploadStatus.className = 'upload-status';
                }, 3000);
                
            } catch (error) {
                console.error('Upload failed:', error);
                showUploadStatus(`‚ùå Upload failed: ${error.message}`, 'error');
                docRow.querySelector('.doc-icon').textContent = '‚ùå';
                docRow.querySelector('.doc-info').textContent = 'Upload failed';
            }
        }

        function readFileAsBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsDataURL(file);
            });
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // File input change handler
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file && isConnected && room) {
                uploadDocument(file);
            } else if (!isConnected) {
                showUploadStatus('‚ùå Connect to call first', 'error');
            }
            fileInput.value = '';
        });

        // Drag and drop handlers
        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });

        uploadSection.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
        });

        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            
            const file = e.dataTransfer.files[0];
            if (file && isConnected && room) {
                uploadDocument(file);
            } else if (!isConnected) {
                showUploadStatus('‚ùå Connect to call first', 'error');
            }
        });

        // =====================================================================
        // AUDIO MONITORING
        // =====================================================================
        function monitorLocalAudioLevel(track) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(new MediaStream([track.mediaStreamTrack]));
                source.connect(analyser);
                analyser.fftSize = 256;
                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                const THRESHOLD = 30, SILENCE_MS = 800;
                let silenceStart = null;

                function check() {
                    if (!isConnected) return;
                    analyser.getByteFrequencyData(dataArray);
                    const avg = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
                    if (avg > THRESHOLD) {
                        if (!latencyMetrics.isSpeaking) {
                            latencyMetrics.isSpeaking = true;
                            latencyMetrics.userSpeechStartTime = performance.now();
                        }
                        silenceStart = null;
                    } else if (latencyMetrics.isSpeaking) {
                        if (!silenceStart) silenceStart = performance.now();
                        else if (performance.now() - silenceStart > SILENCE_MS) {
                            latencyMetrics.isSpeaking = false;
                            latencyMetrics.userSpeechEndTime = performance.now();
                            silenceStart = null;
                        }
                    }
                    requestAnimationFrame(check);
                }
                check();
            } catch (e) { console.warn('Local audio monitor failed', e); }
        }

        function monitorRemoteAudioLevel(track) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(new MediaStream([track.mediaStreamTrack]));
                source.connect(analyser);
                analyser.fftSize = 256;
                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                const THRESHOLD = 20;

                function check() {
                    if (!isConnected) return;
                    analyser.getByteFrequencyData(dataArray);
                    const avg = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
                    if (avg > THRESHOLD && !latencyMetrics.isAgentSpeaking) {
                        latencyMetrics.isAgentSpeaking = true;
                        if (latencyMetrics.userSpeechEndTime) {
                            const latency = performance.now() - latencyMetrics.userSpeechEndTime;
                            latencyMetrics.measurements.push(latency);
                            if (latencyMetrics.measurements.length > latencyMetrics.maxSamples) latencyMetrics.measurements.shift();
                            updateLatencyDisplay();
                            latencyMetrics.userSpeechEndTime = null;
                        }
                    } else if (avg <= THRESHOLD) {
                        latencyMetrics.isAgentSpeaking = false;
                    }
                    requestAnimationFrame(check);
                }
                check();
            } catch (e) { console.warn('Remote audio monitor failed', e); }
        }

        // =====================================================================
        // ROOM CONNECTION
        // =====================================================================
        startBtn.addEventListener('click', async () => {
            try {
                startBtn.disabled = true;
                setStatus('Connecting...', 'connecting');

                const agentId = agentIdInput.value.trim() || 'test-agent';
                const language = languageSelect.value;
                const callId = `call_${Date.now()}`;
                const deviceType = /Mobile|Android|iPhone/i.test(navigator.userAgent) ? 'mobile' : 'desktop';

                const response = await fetch('https://python.service.callshivai.com/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ agent_id: agentId, language, call_id: callId, device: deviceType, user_agent: navigator.userAgent })
                });
                const data = await response.json();

                room = new LivekitClient.Room({
                    adaptiveStream: true,
                    dynacast: true,
                    audioCaptureDefaults: {
                        noiseSuppression: noiseSuppressionCheckbox.checked,
                        echoCancellation: echoCancellationCheckbox.checked,
                        autoGainControl: autoGainControlCheckbox.checked,
                    }
                });

                room.on(LivekitClient.RoomEvent.TrackSubscribed, (track, publication, participant) => {
                    if (track.kind === LivekitClient.Track.Kind.Audio) {
                        const audioElement = track.attach();
                        audioElement.style.display = 'none';
                        document.body.appendChild(audioElement);
                        audioElement.play().catch(() => {});
                        remoteAudioTrack = track;
                        monitorRemoteAudioLevel(track);
                    }
                });

                room.on(LivekitClient.RoomEvent.DataReceived, (payload, participant, kind, topic) => {
                    try {
                        const decoder = new TextDecoder();
                        const text = decoder.decode(payload);
                        const data = JSON.parse(text);
                        
                        // Check if it's a link message
                        if (data.type === 'link') {
                            appendLinkMessage(data.title || 'Link', data.url, data.timestamp);
                            console.log('üìé Link received:', data.title, '‚Üí', data.url);
                            return;
                        }
                    } catch (e) {
                        // Not JSON or failed to parse
                    }
    
                    if (topic === 'lk.transcripts' || topic === 'lk.transcription') {
                        try {
                            const text = new TextDecoder().decode(payload);
                            const data = JSON.parse(text);
                            if (data.text && data.text.trim()) {
                                const isUser = data.role === 'user';
                                appendChatMessage(isUser ? 'You' : 'AI Assistant', data.text, {
                                    role: data.role || (isUser ? 'user' : 'agent'),
                                    time: new Date().toLocaleTimeString(),
                                    isVoiceTranscript: true
                                });
                                addLog(cleanTranscript(data.text), data.role || 'agent');
                            }
                        } catch (e) {}
                        return;
                    }

                    if (topic === 'lk.chat') {
                        try {
                            const data = JSON.parse(new TextDecoder().decode(payload));
                            if (data.text && participant?.identity !== room.localParticipant?.identity) {
                                appendChatMessage('AI Assistant', data.text, { role: 'agent', time: new Date().toLocaleTimeString() });
                            }
                        } catch (e) {}
                    }
                });

                room.on(LivekitClient.RoomEvent.Connected, async () => {
                    setStatus('‚úÖ Connected - Speak now!', 'connected');
                    visualizer.classList.add('active');
                    transcriptBox.classList.add('active');
                    latencyMonitor.classList.add('active');
                    chatBox.classList.add('active');
                    uploadSection.classList.remove('disabled');
                    if (noiseSuppressionCheckbox.checked) noiseIndicator.classList.add('active');
                    startBtn.style.display = 'none';
                    endBtn.style.display = 'block';
                    isConnected = true;

                    if (typeof room.registerTextStreamHandler === 'function') {
                        room.registerTextStreamHandler('lk.transcription', async (reader, participantInfo) => {
                            try {
                                const text = await reader.readAll();
                                if (text && text.trim()) {
                                    const isUser = participantInfo.identity === room.localParticipant?.identity;
                                    appendChatMessage(isUser ? 'You' : 'AI Assistant', text, {
                                        role: isUser ? 'user' : 'agent',
                                        time: new Date().toLocaleTimeString(),
                                        isVoiceTranscript: true
                                    });
                                    addLog(cleanTranscript(text), isUser ? 'user' : 'agent');
                                }
                            } catch (e) {}
                        });
                    }
                });

                room.on(LivekitClient.RoomEvent.Disconnected, cleanup);
                await room.connect(data.url, data.token);

                await room.localParticipant.setMicrophoneEnabled(true, {
                    noiseSuppression: noiseSuppressionCheckbox.checked,
                    echoCancellation: echoCancellationCheckbox.checked,
                    autoGainControl: autoGainControlCheckbox.checked,
                    channelCount: 1, sampleRate: 48000, sampleSize: 16,
                });

                const audioTracks = Array.from(room.localParticipant.audioTrackPublications.values());
                if (audioTracks.length > 0) {
                    localAudioTrack = audioTracks[0].track;
                    monitorLocalAudioLevel(localAudioTrack);
                }
            } catch (error) {
                console.error('Connection error:', error);
                setStatus(`‚ùå Error: ${error.message || error}`, 'error');
                startBtn.disabled = false;
            }
        });

        endBtn.addEventListener('click', async () => {
            if (room) await room.disconnect();
            cleanup();
        });

        function cleanup() {
            if (room) { try { room.disconnect(); } catch (e) {} room = null; }
            isConnected = false;
            localAudioTrack = null;
            remoteAudioTrack = null;
            startBtn.disabled = false;
            startBtn.style.display = 'block';
            endBtn.style.display = 'none';
            visualizer.classList.remove('active');
            noiseIndicator.classList.remove('active');
            uploadSection.classList.add('disabled');            setStatus('Call ended', 'error');
            document.querySelectorAll('audio').forEach(el => el.remove());
        }

        window.addEventListener('beforeunload', cleanup);
        uploadSection.classList.add('disabled');


        // =====================================================================
        // INITIALIZATION
        // =====================================================================
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üéôÔ∏è Voice Assistant Ready');
            console.log('üìÑ Document upload feature enabled');
            console.log('üìù Running transliteration tests...\n');
            HindiTransliterator.test();
        });
    </script>
</body>
</html>